{"ast":null,"code":"import _asyncToGenerator from \"/Users/mehulsharma/projects/practice/passkeys-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/* [@simplewebauthn/browser@6.2.2] */\nfunction utf8StringToBuffer(value) {\n  return new TextEncoder().encode(value);\n}\nfunction bufferToBase64URLString(buffer) {\n  const bytes = new Uint8Array(buffer);\n  let str = '';\n  for (const charCode of bytes) {\n    str += String.fromCharCode(charCode);\n  }\n  const base64String = btoa(str);\n  return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\nfunction base64URLStringToBuffer(base64URLString) {\n  const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n  const padLength = (4 - base64.length % 4) % 4;\n  const padded = base64.padEnd(base64.length + padLength, '=');\n  const binary = atob(padded);\n  const buffer = new ArrayBuffer(binary.length);\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return buffer;\n}\nfunction browserSupportsWebAuthn() {\n  return (window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function';\n}\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n  const {\n    id\n  } = descriptor;\n  return {\n    ...descriptor,\n    id: base64URLStringToBuffer(id),\n    transports: descriptor.transports\n  };\n}\nfunction isValidDomain(hostname) {\n  return hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname);\n}\nclass WebAuthnError extends Error {\n  constructor(message, name = 'WebAuthnError') {\n    super(message);\n    this.name = name;\n  }\n}\nfunction identifyRegistrationError({\n  error,\n  options\n}) {\n  var _a, _b;\n  const {\n    publicKey\n  } = options;\n  if (!publicKey) {\n    throw Error('options was missing required publicKey property');\n  }\n  if (error.name === 'AbortError') {\n    if (options.signal === new AbortController().signal) {\n      return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n    }\n  } else if (error.name === 'ConstraintError') {\n    if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n      return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n    } else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n      return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n    }\n  } else if (error.name === 'InvalidStateError') {\n    return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n  } else if (error.name === 'NotAllowedError') {\n    return new WebAuthnError('User clicked cancel, or the registration ceremony timed out', 'NotAllowedError');\n  } else if (error.name === 'NotSupportedError') {\n    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n    if (validPubKeyCredParams.length === 0) {\n      return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n    }\n    return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n  } else if (error.name === 'SecurityError') {\n    const effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n    } else if (publicKey.rp.id !== effectiveDomain) {\n      return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n    }\n  } else if (error.name === 'TypeError') {\n    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n      return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n    }\n  } else if (error.name === 'UnknownError') {\n    return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n  }\n  return error;\n}\nclass WebAuthnAbortService {\n  createNewAbortSignal() {\n    if (this.controller) {\n      this.controller.abort('Cancelling existing WebAuthn API call for new one');\n    }\n    this.controller = new AbortController();\n    return this.controller.signal;\n  }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\nfunction startRegistration(_x) {\n  return _startRegistration.apply(this, arguments);\n}\nfunction _startRegistration() {\n  _startRegistration = _asyncToGenerator(function* (creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n      throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n      ...creationOptionsJSON,\n      challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n      user: {\n        ...creationOptionsJSON.user,\n        id: utf8StringToBuffer(creationOptionsJSON.user.id)\n      },\n      excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor)\n    };\n    const options = {\n      publicKey\n    };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n      credential = yield navigator.credentials.create(options);\n    } catch (err) {\n      throw identifyRegistrationError({\n        error: err,\n        options\n      });\n    }\n    if (!credential) {\n      throw new Error('Registration was not completed');\n    }\n    const {\n      id,\n      rawId,\n      response,\n      type\n    } = credential;\n    const credentialJSON = {\n      id,\n      rawId: bufferToBase64URLString(rawId),\n      response: {\n        attestationObject: bufferToBase64URLString(response.attestationObject),\n        clientDataJSON: bufferToBase64URLString(response.clientDataJSON)\n      },\n      type,\n      clientExtensionResults: credential.getClientExtensionResults(),\n      authenticatorAttachment: credential.authenticatorAttachment\n    };\n    if (typeof response.getTransports === 'function') {\n      credentialJSON.transports = response.getTransports();\n    }\n    return credentialJSON;\n  });\n  return _startRegistration.apply(this, arguments);\n}\nfunction bufferToUTF8String(value) {\n  return new TextDecoder('utf-8').decode(value);\n}\nfunction browserSupportsWebAuthnAutofill() {\n  return _browserSupportsWebAuthnAutofill.apply(this, arguments);\n}\nfunction _browserSupportsWebAuthnAutofill() {\n  _browserSupportsWebAuthnAutofill = _asyncToGenerator(function* () {\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return globalPublicKeyCredential.isConditionalMediationAvailable !== undefined && globalPublicKeyCredential.isConditionalMediationAvailable();\n  });\n  return _browserSupportsWebAuthnAutofill.apply(this, arguments);\n}\nfunction identifyAuthenticationError({\n  error,\n  options\n}) {\n  var _a;\n  const {\n    publicKey\n  } = options;\n  if (!publicKey) {\n    throw Error('options was missing required publicKey property');\n  }\n  if (error.name === 'AbortError') {\n    if (options.signal === new AbortController().signal) {\n      return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n    }\n  } else if (error.name === 'NotAllowedError') {\n    if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n      return new WebAuthnError('No available authenticator recognized any of the allowed credentials', 'NotAllowedError');\n    }\n    return new WebAuthnError('User clicked cancel, or the authentication ceremony timed out', 'NotAllowedError');\n  } else if (error.name === 'SecurityError') {\n    const effectiveDomain = window.location.hostname;\n    if (!isValidDomain(effectiveDomain)) {\n      return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n    } else if (publicKey.rpId !== effectiveDomain) {\n      return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n    }\n  } else if (error.name === 'UnknownError') {\n    return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n  }\n  return error;\n}\nfunction startAuthentication(_x2) {\n  return _startAuthentication.apply(this, arguments);\n}\nfunction _startAuthentication() {\n  _startAuthentication = _asyncToGenerator(function* (requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n      throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n      allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n      ...requestOptionsJSON,\n      challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n      allowCredentials\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n      if (!(yield browserSupportsWebAuthnAutofill())) {\n        throw Error('Browser does not support WebAuthn autofill');\n      }\n      const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n      if (eligibleInputs.length < 1) {\n        throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n      }\n      options.mediation = 'conditional';\n      publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n      credential = yield navigator.credentials.get(options);\n    } catch (err) {\n      throw identifyAuthenticationError({\n        error: err,\n        options\n      });\n    }\n    if (!credential) {\n      throw new Error('Authentication was not completed');\n    }\n    const {\n      id,\n      rawId,\n      response,\n      type\n    } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n      userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n      id,\n      rawId: bufferToBase64URLString(rawId),\n      response: {\n        authenticatorData: bufferToBase64URLString(response.authenticatorData),\n        clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n        signature: bufferToBase64URLString(response.signature),\n        userHandle\n      },\n      type,\n      clientExtensionResults: credential.getClientExtensionResults(),\n      authenticatorAttachment: credential.authenticatorAttachment\n    };\n  });\n  return _startAuthentication.apply(this, arguments);\n}\nfunction platformAuthenticatorIsAvailable() {\n  return _platformAuthenticatorIsAvailable.apply(this, arguments);\n}\nfunction _platformAuthenticatorIsAvailable() {\n  _platformAuthenticatorIsAvailable = _asyncToGenerator(function* () {\n    if (!browserSupportsWebAuthn()) {\n      return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n  });\n  return _platformAuthenticatorIsAvailable.apply(this, arguments);\n}\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };","map":{"version":3,"names":["utf8StringToBuffer","value","TextEncoder","encode","bufferToBase64URLString","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","base64String","btoa","replace","base64URLStringToBuffer","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","browserSupportsWebAuthn","window","PublicKeyCredential","undefined","toPublicKeyCredentialDescriptor","descriptor","id","transports","isValidDomain","hostname","test","WebAuthnError","Error","constructor","message","name","identifyRegistrationError","error","options","_a","_b","publicKey","signal","AbortController","authenticatorSelection","requireResidentKey","userVerification","validPubKeyCredParams","pubKeyCredParams","filter","param","type","effectiveDomain","location","rp","user","byteLength","WebAuthnAbortService","createNewAbortSignal","controller","abort","webauthnAbortService","startRegistration","creationOptionsJSON","challenge","excludeCredentials","map","credential","navigator","credentials","create","err","rawId","response","credentialJSON","attestationObject","clientDataJSON","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","getTransports","bufferToUTF8String","TextDecoder","decode","browserSupportsWebAuthnAutofill","globalPublicKeyCredential","isConditionalMediationAvailable","identifyAuthenticationError","allowCredentials","rpId","startAuthentication","requestOptionsJSON","useBrowserAutofill","eligibleInputs","document","querySelectorAll","mediation","get","userHandle","authenticatorData","signature","platformAuthenticatorIsAvailable","isUserVerifyingPlatformAuthenticatorAvailable"],"sources":["/Users/mehulsharma/projects/practice/passkeys-angular/node_modules/@simplewebauthn/browser/dist/bundle/index.js"],"sourcesContent":["/* [@simplewebauthn/browser@6.2.2] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor(message, name = 'WebAuthnError') {\n        super(message);\n        this.name = name;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n        }\n        else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError('User clicked cancel, or the registration ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n        }\n        return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            this.controller.abort('Cancelling existing WebAuthn API call for new one');\n        }\n        this.controller = new AbortController();\n        return this.controller.signal;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    const credentialJSON = {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n    if (typeof response.getTransports === 'function') {\n        credentialJSON.transports = response.getTransports();\n    }\n    return credentialJSON;\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    var _a;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n            return new WebAuthnError('No available authenticator recognized any of the allowed credentials', 'NotAllowedError');\n        }\n        return new WebAuthnError('User clicked cancel, or the authentication ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}